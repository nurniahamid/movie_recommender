# -*- coding: utf-8 -*-
"""movie_recomendation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bm1oYOJOuyHjdP2jGjNVrgqrJmM3hTR_

# **Pertanyaan Bisnis**

1. Bagaimana memberikan rekomendasi film yang relevan kepada pengguna berdasarkan preferensi genre yang dimilikinya?

2. Bagaimana menyarankan film kepada pengguna dengan mempertimbangkan perilaku pengguna lain yang memiliki preferensi serupa?

Goals

1. Membangun sistem rekomendasi berbasis konten (content-based filtering) yang dapat menganalisis informasi film (seperti genre) untuk memberikan saran yang sesuai dengan riwayat tontonan pengguna.

2. Mengembangkan sistem rekomendasi berbasis kolaboratif (collaborative filtering) yang dapat memberikan saran kepada pengguna berdasarkan pola rating dan preferensi dari pengguna lain yang serupa.
"""

import pandas as pd

"""# **Data Understanding**"""

from google.colab import files
files.upload()

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json
!kaggle datasets download -d gargmanas/movierecommenderdataset
!unzip movierecommenderdataset.zip -d movierecommenderdataset

movies = pd.read_csv('movierecommenderdataset/movies.csv')
ratings = pd.read_csv('movierecommenderdataset/ratings.csv')

print('Jumlah data film: ', len(movies.movieId.unique()))
print('Jumlah data penilaian yang diberikan pengguna: ', len(ratings.movieId.unique()))

"""Variabel dalam data :
- Movies : merupakan jumlah data film
- rating : merupakan data rating pengguna terhadap film

# **Univariate Exploratory Data Analysis**
"""

movies

#variabel movies
movies.info()

"""melihat ada berapa banyak data berdasarkan movieId dan untuk mengetahui jenis-jenis genre yang ada dalam data"""

print('Banyak Data : ', len(movies.movieId.unique()))
print('Jumlah Jenis Genre film : ', len(movies.genres.unique()))
print('Jenis Genre film: ', movies.genres.unique())

# variabel ratings
ratings.info()

print('Banyaknya data rating : ', len(ratings.userId.unique()))
print('Banyaknya film yang di rating : ', len(ratings.movieId.unique()))

ratings.describe()

"""# **Data Preprocessing**

#### Menggabungkan data movies dan ratings
"""

merged_df = pd.merge(ratings, movies, on='movieId', how='left')
merged_df

merged_df.isnull().sum()

merged_df.duplicated().sum()

"""mempertahankan genre multi-kata dalam kolom genre agar tidak dianggap sebagai dua genre yang berbeda, jadi kita akan mengganti tanda (-) menjadi (_) sebelum vektorisasi dan mengubah Kolom genres dalam format Adventure|Animation|Children menjadi Adventure Animation Children atau mengubah tanda pemisal menjadi spasi"""

merged_df['genres'] = (
    merged_df['genres']
    .str.lower()
    .str.replace('-', '_')
    .str.replace('|', ' ')
)
merged_df

"""menghapus data duplikasi yang memiliki movieId yang sama. karena 1 film bisa muncul berkali-kali(karena user berbeda dalam ratings), sedangkan kita hanya ingin satu data unik untuk per film"""

movie_content_df = merged_df[['movieId', 'title', 'genres']].drop_duplicates('movieId')
movie_content_df.reset_index(drop=True, inplace=True)
movie_content_df.head()

#Mengkonversi data series 'movieID' menjadi dalam bentuk list
movie_id = movie_content_df['movieId'].tolist()

#mengkonversi data series 'title' menjadi dalam bentuk list
movie_title = movie_content_df['title'].tolist()

#Mengkonversi data series 'genres' menjadi dalam bentk list
movie_genres = movie_content_df['genres'].tolist()

print(len(movie_id))
print(len(movie_title))
print(len(movie_genres))

"""setelah itu buat dictionary untuk menentukan pasangan key-value pada data movie_id, movie_title, dan movie_genres yang telah kita siapkan sebelumnya."""

movie_new = pd.DataFrame ({
    'id' : movie_id,
    'movie_title' : movie_title,
    'genres': movie_genres
})

movie_new

print(sorted(movie_new['genres'].unique()))

"""# **Model Development dengan Content Based Filtering**

"""

df = movie_new
df.sample(5)

"""# **TF-IDF Vectorizer**"""

print(sorted(df['genres'].unique()))

from sklearn.feature_extraction.text import TfidfVectorizer

# Inisialisasi TfidfVectorizer
tf = TfidfVectorizer()

# Melakukan perhitungan idf pada data genres
tf.fit(df['genres'])

# Mapping array dari fitur index integer ke fitur nama
tf.get_feature_names_out()

"""selanjutnya kita akan melakukan fit dan transformasi kedalam bentuk matriks"""

#Melakukan fit lalu ditransformasikan ke bentuk matrix
tfidf_matrix = tf.fit_transform(df['genres'])

#melihat ukuran matrix tfidf
tfidf_matrix.shape

"""Untuk menghasilkan vektor tf-idf dalam bentuk matriks, kita menggunakan fungsi todense()"""

# Mengubah vektor tf-idf dalam bentuk matriks dengan fungsi todense()
tfidf_matrix.todense()

"""kemudian mengubah matriks Tf_IDF menjadi sebuah DataFrame yang lebih mudah dibaca"""

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tf.get_feature_names_out(),
    index=df.movie_title
).sample(21, axis=1).sample(10, axis=0)

"""Pada tahap sebelumnya, kita telah berhasil mengidentifikasi korelasi antara movie dengan genre. Sekarang, kita akan menghitung derajat kesamaan (similarity degree) dengan teknik cosine similarity."""

from sklearn.metrics.pairwise import cosine_similarity

#Menghitung cosine similarity pada matrix tf-idf
cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

"""Pada tahapan ini, kita menghitung cosine similarity dataframe tfidf_matrix yang kita peroleh pada tahapan sebelumnya. Dengan satu baris kode untuk memanggil fungsi cosine similarity dari library sklearn, kita telah berhasil menghitung kesamaan (similarity) antar movie.


Selanjutnya, mari kita lihat matriks kesamaan setiap movie dengan menampilkan nama film dalam 5 sampel kolom (axis = 1) dan 10 sampel baris (axis=0).
"""

#Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa nama resto

cosine_sim_df = pd.DataFrame(cosine_sim, index=df['movie_title'], columns=df['movie_title'] )

#Melihat similarity matrix pada setiap movie
cosine_sim_df.sample(5, axis=1). sample(10, axis=0)

"""#### **Rekomendasi**"""

def movie_recommendations(movie_title, similarity_data=cosine_sim_df, items=df[['movie_title', 'genres']], k=5):
    index = similarity_data.loc[:,movie_title].to_numpy().argpartition(
        range(-1, -k, -1))
    closest = similarity_data.columns[index[-1:-(k+2):-1]]
    closest = closest.drop(movie_title, errors='ignore')
    return pd.DataFrame(closest).merge(items).head(k)

df[df.movie_title.eq('Waterboy, The (1998)')]

#Mendapatkan rekomendasi movie yang mirip dengan 'Waterboy, The (1998)'
movie_recommendations('Waterboy, The (1998)')

"""Berdasarkan hasil rekomendasi film yang memiliki genre yang sama dengan 'Waterboy, The (1998)' adalah :
1. Private Benjamin (1980)	comedy
2. Judd Apatow: The Return (2017)	comedy
3. Dad's Army (2016)	comedy
4. Craig Ferguson: Tickle Fight (2017)	comedy
5. Dad's Army (1971)	comedy
"""

def evaluate_genre_precision_recall(movie_title, k=5):
    # Ambil genre dari film input
    input_row = df[df['movie_title'] == movie_title]
    if input_row.empty:
        return f"Film '{movie_title}' tidak ditemukan di dataset."

    input_genres = input_row['genres'].values[0].lower().split('|')

    # Ambil hasil rekomendasi
    recommendations = movie_recommendations(movie_title, k=k)

    # Hitung precision: berapa banyak film yang punya genre cocok
    relevant_count = 0
    for _, row in recommendations.iterrows():
        rec_genres = row['genres'].lower().split('|')
        if any(g in input_genres for g in rec_genres):
            relevant_count += 1
    precision = relevant_count / k

    # Hitung recall: apakah genre dari film input muncul di hasil rekomendasi
    recommended_genres = set()
    for _, row in recommendations.iterrows():
        rec_genres = row['genres'].lower().split('|')
        recommended_genres.update(rec_genres)

    recall = len(set(input_genres).intersection(recommended_genres)) / len(input_genres)

    return {
        'movie_input': movie_title,
        'input_genre': input_genres,
        'precision': round(precision, 2),
        'recall': round(recall, 2)
    }

evaluate_genre_precision_recall('Waterboy, The (1998)')

"""dari hasil di atas yang kita dapatkan :
- Precision = 1.0 → Semua film yang direkomendasikan memang punya genre yang relevan dengan film input (comedy)

- Recall = 1.0 → Genre dari film input (comedy) tercakup di rekomendasi

selanjutnya kita akan melakukan evaluasi untuk 20 film secara acak, dan menghitung rata-rata precion dan recall
"""

sample_movies = df['movie_title'].drop_duplicates().sample(20, random_state=42)

results = [evaluate_genre_precision_recall(title) for title in sample_movies]
precision_scores = [r['precision'] for r in results if isinstance(r, dict)]
recall_scores = [r['recall'] for r in results if isinstance(r, dict)]

avg_precision = sum(precision_scores) / len(precision_scores)
avg_recall = sum(recall_scores) / len(recall_scores)

print(f"Average Precision: {avg_precision:.2f}")
print(f"Average Recall: {avg_recall:.2f}")

"""Dari hasilnya di dapatkan :
- Average Precision = 0.96
Rata-rata 96% dari film yang direkomendasikan relevan (punya genre yang cocok).

- Average Recall = 1.00
Rata-rata, semua genre film input berhasil tercakup di hasil rekomendasi (genre utama selalu ketemu).

# Model Collaborative Filtering

model rekomendasi berbasis Collaborative Filtering (CF), khususnya item-based collaborative filtering dengan pendekatan Pearson Correlation sebagai ukuran kemiripan antar item (film).
"""

merged_df

"""menghitung jumlah review atau rating dari masing-masing judul film yang diberikan oleh user"""

comment_counts = merged_df["title"].value_counts().reset_index()
comment_counts.columns = ['title', 'count_user']
comment_counts.head(5)

"""filter film berdasarkan popularitas atau jumlah user rating"""

popular_movies = comment_counts[comment_counts["count_user"] >= 50]['title'].tolist()
popular_movies

"""sekarang kita akan membuat matriks pengguna vs film. Dimana :
- baris = userId
- kolom = title (judul film)
- Nilai = rating yang diberikan user ke film tersebut
"""

# Filter data hanya untuk film-film dalam cut_movies
filtered_df = merged_df[merged_df['title'].isin(popular_movies)]

# Buat matriks user vs film, isi nilainya adalah rating
user_movie_matrix = filtered_df.pivot_table(index='userId', columns='title', values='rating')

# Lihat hasil awal
user_movie_matrix.head()

user_movie_matrix.shape

user_movie_matrix.columns

"""- membuat similarity matrix menggunakan Pearson Correlation:
Punya matriks user-film
Baris = userId
Kolom = judul film
Nilai = rating user ke film tersebut

- Hitung korelasi antar film
Kita hitung Pearson correlation antar kolom (film).
Dengan ini, kita tahu seberapa mirip pola rating antar dua film.

- Gunakan matriks korelasi ini untuk rekomendasi
Kalau user suka film A, rekomendasikan film-film yang punya korelasi tinggi dengan film A.

menghitung matrix person correlation antar film. korelaasi dihitung hanya untuk film yang memiliki minimal nilai 5, untuk user yang sama-sama memberikan rating
"""

movie_similarity = user_movie_matrix.corr(method='pearson', min_periods=5)

"""Nilai korelasi:

- (1) artinya pola rating kedua film sangat mirip.

- (0) artinya tidak ada korelasi.

- (-1) artinya pola rating berlawanan (jika suka satu, biasanya tidak suka yang lain).


"""

print(movie_similarity.head())

""" mencari film yang paling mirip dengan film yang dipilih (movie_title). Pertama, fungsi mengambil skor korelasi antara film lain dengan film tersebut. Selanjutnya, film yang sama dengan movie_title dihapus agar tidak muncul sebagai rekomendasi. Setelah itu, skor korelasi diurutkan dari yang tertinggi ke terendah, dan akhirnya fungsi mengembalikan 5 film teratas sebagai rekomendasi"""

#def recommend_movies(movie_title, movie_similarity, top_n=5):
 #   if movie_title not in movie_similarity.columns:
  #      print("Film tidak ditemukan di data.")
   #     return

#    sim_scores = movie_similarity[movie_title].dropna()
#   sim_scores = sim_scores.drop(labels=[movie_title])
 #   top_movies = sim_scores.sort_values(ascending=False).head(top_n)

  #  print(f"Rekomendasi film mirip dengan '{movie_title}':\n")
   # for i, (title, score) in enumerate(top_movies.items(), start=1):
    #    print(f"{i}. {title} (Skor kemiripan: {score:.3f})")

def recommend_movies(movie_title, movie_similarity, top_n=5):
    if movie_title not in movie_similarity.columns:
        print("Film tidak ditemukan di data.")
        return pd.DataFrame()

    sim_scores = movie_similarity[movie_title].dropna()
    sim_scores = sim_scores.drop(labels=[movie_title], errors='ignore')
    top_movies = sim_scores.sort_values(ascending=False).head(top_n)

    # Return dataframe rekomendasi
    return pd.DataFrame({
        'movie_title': top_movies.index,
        'similarity_score': top_movies.values
    })

# Mencari rekomendasi untuk film "Forrest Gump (1994)"
recommendations = recommend_movies('Forrest Gump (1994)', movie_similarity)
print(recommendations)

"""berdasarkan rekomendasi kelima film tersebut punya pola rating yang cukup mirip dengan "Forrest Gump (1994)".

Korelasi di atas 0.5 cukup tinggi untuk rekomendasi film.

Jadi, jika user suka "Forrest Gump (1994)", sistem menyarankan film-film tersebut.
"""

def evaluate_cf_precision_recall(movie_title, movie_similarity, df, k=5):
    # Ambil genre film input
    input_row = df[df['movie_title'] == movie_title]
    if input_row.empty:
        return f"Film '{movie_title}' tidak ditemukan di dataset."

    input_genres = input_row['genres'].values[0].lower().split(' ')

    # Ambil rekomendasi
    recommendations = recommend_movies(movie_title, movie_similarity, top_n=k)
    if recommendations.empty:
        return f"Tidak ada rekomendasi untuk film '{movie_title}'."

    # Hitung precision
    relevant_count = 0
    for rec_title in recommendations['movie_title']:
        rec_genres = df[df['movie_title'] == rec_title]['genres'].values[0].lower().split(' ')
        if any(g in input_genres for g in rec_genres):
            relevant_count += 1
    precision = relevant_count / k

    # Hitung recall (berapa genre film input yang muncul dalam rekomendasi)
    recommended_genres = set()
    for rec_title in recommendations['movie_title']:
        rec_genres = df[df['movie_title'] == rec_title]['genres'].values[0].lower().split(' ')
        recommended_genres.update(rec_genres)
    recall = len(set(input_genres).intersection(recommended_genres)) / len(input_genres)

    return {
        'movie_input': movie_title,
        'input_genre': input_genres,
        'precision': round(precision, 2),
        'recall': round(recall, 2)
    }

result = evaluate_cf_precision_recall('Forrest Gump (1994)', movie_similarity, df, k=5)
print(result)

